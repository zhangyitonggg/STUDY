$by \ \ Y(t)-22373337$

# 第一大部分 基础理论

## 第一章 数据库系统基本概念（数据模型，体系结构）

![image-20241230014836923](imgs\image-20241230014836923.png)

### 0. 基本概念之前

* 数据与信息的关系
* 数据处理与数据管理
* 数据库技术、数据库管理系统、数据库系统

### 1. 数据管理技术发展的三个阶段

#### 人工管理阶段

* 特点

#### 文件系统阶段

* 特点
* 缺点

#### 数据库系统阶段

**新需求**：集成 + 共享

数据库系统的 **基本问题** 2点，**关键技术** 2点，**核心软件**

**特点** 5点：

* 面向全组织的复杂的数据结构

* 数据冗余度小，易扩充

* 较高的数据和程序的独立性  2点

* 统一的数据控制功能  4点

  安全性控制 + 完整性控制 + 并发控制 + 数据库恢复

* 数据的最小存取单位是数据项

### 2. 数据模型

#### 前言

定义

层次：概念(信息)模型 + 数据模型

#### 概念模型

定义

表示方法：实体——联系方法（E-R法）

* 一些基本概念：实体、属性、码、域、实体型、联系
* E-R图的画法

#### 数据模型

定义

三要素：数据结构、数据操作、完整性规则

分类：层次模型、网状模型、关系模型

### 3. 数据库系统的结构

#### 结构特征
三级模式、两级映像

模式又叫逻辑模式、**概念模式**

#### 三级模式结构的优点

四点：3数据+1用户

* 保证数据的独立性
* 简化用户接口，方便用户使用
* 有利于数据共享
* 有利于数据的安全保密

#### DBMS的功能

> 1个地位+5个功能

* 数据库定义功能

  DDL、源模式、模式翻译程序、目标模式、数据字典

* 数据存取功能

  检索、插入、修改、删除

* 数据库运行管理

  6点

* 数据的组织、存储和管理

* 数据库的建立和维护

#### DBMS的组成

* 语言编译处理程序
* 系统运行控制程序
* 系统建立和维护程序
* **数据字典**

#### DBA

* 建库方面
* 用库方面
* 改进方面

---

## 第二章 关系数据库

![image-20250104190737098](imgs\image-20250104190737098.png)

### 0. 关系模型的基本概念

#### 关系的数学定义

域

元组和分量

关系的定义：关系的名字、关系的度或目

关系可以表示为二维表

**关系数据模型的三要素**

* 数据结构：关系

  关系、域、n目关系、元组、属性、码、候选码、主码、主属性、非主属性

  关系模式是指关系的描述，即R(U, D, dom, F)

  关系是关系模式在某一时刻的状态或内容

* 语义约束

  * 实体完整性

  * 参照完整性

    外部码、参照关系、被参照关系（目标关系）

  * 用户定义完整性

* 数据操作

  * 特点：集合操作

  * 基础：关系运算
    * 代数方式，即关系代数
    * 逻辑方式，即关系演算：元组关系演算+域关系演算

### 1. 关系代数

#### 运算符号

共有9种：

* 常规集合运算：并、差、交、广义笛卡尔积（乘）
* 特有的关系运算：选择、投影、连接、自然连接、除法

#### 分类

从数学角度，基本关系运算有5种：并、差、乘、选择、投影。

从数据库角度，核心的关系运算有：选择、投影、连接（或自然连接）。

### 2. 元组关系演算与域关系演算

#### 元组关系演算

约束元组变量 + 自由元组变量

元组关系演算公式的递归定义

#### 域关系演算

约束域变量 + 自由域变量

域关系验算公式的递归定义

### 3. 三类元组关系的安全约束及等价性

#### 关系运算的安全约束

安全运算、安全表达式、安全约束

关系代数是安全运算。关系演算则不一定，所以要对关系演算进行安全约束

#### 三类关系运算的等价性

**经过安全约束**的三类关系运算的表达能力是等价的，可以相互转换

### 4. 关系数据语言概述

#### 数据库数据语言

从功能上分为以下几种：

* 数据定义语言DDL
* 数据操纵语言DML
  * 联机交互方式
  * 宿主语言方式
* 数据控制语言DCL

#### 关系数据语言特点

1. 一体化
2. 非过程化
3. 面向集合的存取方式
4. 既可独立使用又可与主语言嵌套使用

关系数据语言优越性的根源

#### 关系数据语言分类

### 5. 关系模型的优点与缺点

---

## 第三章 关系数据库标准语言SQL

![image-20250104215218247](imgs\image-20250104215218247.png)

### 0. 概述

#### SQL特点

* 综合统一
* 高度非过程化
* 面向集合的操作方式
* 以同一种语法结构提供两种使用方式
* 语言简捷，易学易用

#### 基本表与导出表

导出表：视图 + 快照

### 1. SQL数据查询功能

> 可以给表定义**别名**

* 投影检索：

  SELECT SN, SA FROM S

  采用**DISTINCT**消去重复行

* 选取检索：

  由WHERE子句指出查询条件

  运算符分类：

  * 比较运算符：<>是不等号
  * 布尔运算符：AND，OR，NOT
  * 括号
  * BETWEEN ... AND ... 表示某个区间

* 排序检索：

  ORDER BY 列名 ASC(缺省) / DESC

  在SELECT语句中作为**最后一个子句**出现

* 普通连表检索

  SELECT SN, C#, G FROM S, SC WHERE S.S#=SC>S# AND SN='**张奕彤**'

  第一个是连表条件，第二个是选取条件

* 外连接 

  在连接谓词某一边加 `(*)` 或者 `(+)`

* 子查询嵌套检索

  * 分为普通子查询和相关子查询
  
  * 如果子查询返回单值，可以直接用比较运算符等连接子查询；
  
    如果子查询返回一组值，则必须插入ANY、ALL等操作符。
  
  * `IN`：属于运算，代替`=ANY`
  
  * `NOT IN`：不属于运算，代替`!=ALL`
  
  * `EXISTS`：子查询结果非空时为真
  
  * `NOT EXISTS`：子查询结果为空时为真
  
    * 可以用于表示全称量词
    * 可以用于表示蕴含
  
* 并、差、交的SQL运算符：`UNION` `MINUS` `INTERSECT`
  
  操作对象必须是相容的
  
* 库函数检索：
  
  只能在SELECT子句以及HAVING子句中出现
  
  * `COUNT()`按列值计个数
  
    SELECT COUNT(DISTINCT S#) FROM SC
  
  * `COUNT(*)`按行数计个数
  
  * `SUM()`对数值列求总和
  
  * `ACG()`对数值列求平均值
  
  * `MAX()`对列找最大值
  
  * `MIN()`对列找最小值
  
* 分组检索
  
  WHERE——GROUP BY 列名——HAVING 分组条件
  
* 算术表达式值的检索
  
* 部分匹配查询
  
   **`列名  LIKE/NOT LIKE  字符串常量`**
  
  * 列名必须为字符型或变长字符型
  * `%`：代表任意序列的0个或多个字符
  * `_`：代表任意单个字符
  
* 基于派生表的查询
  
  ```sql
  SELECT S#, C#
  FROM SC, (SELECT S#, AVG(G)
           FROM SC
           GROUP BY S#) AS AVG_SC(AVG_S#, AVG_G) /*临时派生表*/
  WHERE SC.S# = AVG_SC.AVG_S#
  ```
  
  * `AS`关键字可以省略，但必须为派生表**指定别名**
  * 如果子查询中没有库函数，则派生表可以不指定列

### 2. SQL数据定义功能

#### 定义、删除、修改基本表

**定义基本表**

* 完整性约束

  分列级和表级

  * NULL/NOT NULL 

  * UNIQUE

  * PRIMARY KEY 

    PRIMARY KEY(S#)

  * FOREIGN KEY

    FOREIGH KEY(C#) **references** C(C#)

  * CHECK 

    CHECK (SA >= 18 and SA <=45)

* 数据类型

  * int
  * char(n)
  * varchar(n)
  * date
  * numeric(p,q)
  * 等

**修改基本表**

```sql
ALTER Table <表名>
[Add <新列名> <数据类型> [<完整性约束>]] |
[Drop <完整性约束>] |
[Modify <列名> <数据类型>] |
[Drop Column <列名>]
```

**删除基本表**

`Drop Table <表名>`

#### 定义、删除索引

**定义索引**

```sql
Create [Unique] [Cluster] Index <索引名>
	On <表名>(<列名>[次序]...)
```

**删除索引**

```sql
Drop Index <索引名>
```

#### 定义、删除视图

**定义视图**

```sql
Create View <视图名>[(<列名>, <列名>...)]
As <子查询>
[With Check Option]
```

**删除视图**

```sql
Drop View <视图名>
```

### 3. SQL视图操作

#### 查询视图

视图消解的过程

#### 视图的作用

* 简化用户操作
* 使用户能够以多种角度看待同一数据
* 提供了一定程度的逻辑独立性
* 能够对数据提供安全保护

### 4. SQL数据更新功能

#### 插入数据——Insert语句

* 插入单个元组

  ```sql
  Insert Into <表名>[(<属性列>...)]
  Values(<值>...)
  ```

* 插入子查询结果

  ```sql
  Insert Into <表名>[(<属性列>...)]
  <子查询>
  ```

#### 修改数据——Update语句

```sql
Updata <表名>
Set <列名>=<表达式>...
[Where <条件>]
```

#### 删除数据——Delete语句

```sql
Delete From <表名>
[Where <条件>]
```

### 5. SQL数据控制功能

* 定义完整性约束条件
* 支持事务操作
* 提供安全控制功能
  * 授权 `GRANT <权限> [ON <对象类型> <对象名>] TO <用户>`
  * 收回权限 `REVOKE <权限> [ON <对象类型> <对象名>] FROM <用户>`

### 6. 空值的处理

* 空值用`NULL`表示
* 空值与另一个值的算术运算结果为NULL，与另一个值的比较运算结果为UNKNOWN
* TRUE、FALSE、UNKNOWN的AND、OR、NOT运算
* 空值的判断：`IS NULL` + `IS NOT NULL`
* 在检索操作中，只有使WHERE和HAVING子句中的条件为**TRUE**的元组才被输出

### 7. 嵌入式SQL

* 最佳特性的结合
* 预编译
* 临时组装SQL语句

---

## 第四章 数据库保护

![image-20250105023621366](imgs\image-20250105023621366.png)

### 1. 数据库安全性控制

#### 数据库系统的安全性

数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露、更改和破坏

包括两个方面的含义

#### 用户标识与认证

地位：系统提供的**最外层**安全保护措施。

常用方法：采用用户名和口令。

#### 存取控制

定义：存取控制确保合法用户按照指定的权限使用DBMS访问数据，而非法用户或不具有相关权限的用户则不能。

两个部分：用户权限定义+合法权限检查$\rightarrow$DBMS的安全子系统

分类：自主存取控制DAC + 强制存取控制MAC

#### 自主存取控制

* 用户权限：数据对象、操作类型

* 授权

* 基于角色的存取控制

* SQL的数据安全性控制

  * 用户级权限

    ```sql
    Grant <用户级权限>|<角色>...
    To <用户名>|<角色>|public/*全部用户*/...
    [With Grant Option]/*允许被授权的用户将指定的用户级权限或者角色授予其他用户*/
    
    Revoke <用户级权限>|<角色>...
    From <用户名>|<角色>|public...
    ```

  * 关系级权限

    收回权限时，若用户已将权限授予其他用户，则一并收回。

    ```sql
    Grant ALL|<权限>...
    On <表名>|<视图名>...
    To <用户名>|<角色>|public...
    [With Grant Option]
    
    Revoke ALL|<表级权限>...
    On <表名>|<视图名>...
    From <用户>|public...
    ```

#### 强制存取控制

全部实体被分为**主体**和**客体**两类

敏感度标记：

* 主体：许可证级别
* 客体：密级

存取规则：

* 大于等于，读
* 等于，写

#### 数据安全性控制的其他方法

* 视图机制
* 审计
* 数据加密

#### 可信计算机系统评测标准

### 2. 数据库完整性控制 

#### 数据完整性含义

* ==数据完整性是指**数据**的**正确性**和**相容性**==
* 数据完整性关系到数据库系统能否真实地反映现实世界
* 数据完整性与数据安全性的区别

#### 完整性约束条件

完整性约束条件作用的对象可以是列、元组、关系三种

关系模型中的三种完整性约束条件：实体完整性、参照完整性、用户自定义完整性。前两者都是关系约束

完整性约束条件分类：

* 静态约束：反映数据库状态合理性的约束
  * 静态列级约束
  * 静态元组约束
  * 静态关系约束
* 动态约束：反映数据库状态变迁的约束
  * 动态列级约束
  * 动态元组约束
  * 动态关系约束

#### 完整性控制

**完整性控制的功能**：

* 定义功能
* 检查功能
* 违约响应

**完整性检查的时机**：

* 立即执行约束
* 延迟执行约束

**完整性规则的表示**：五元组(D, O, A, C, P)

* D：Data 工资
* O：Operation 插入或修改
* A：Assertion 工资>=5000
* C：Condition 职称=‘教授’
* P：Procedure 拒绝执行该操作

**SQL的数据完整性支持：**

* CREATE TABLE 语句

* 断言

  ```sql
  CREATE ASSERTION <断言名> 
  <CHECK子句>
  ```

* 触发器

  ```sql
  CREATE TRIGGER <触发器名称>
  	{BEFORE|AFTER} <触发器事件> ON <表名>
  	REFERENCING NEW|OLD ROW AS <变量>
  	FOR EACH {ROW|STATEMENT}
  	[WHEN <触发条件>]
  	<触发动作体>
  ```
  
  ![image-20250106171502508](imgs\image-20250106171502508.png)

---

# 第二大部分 设计理论

## 第五章 关系数据理论

![image-20250105150350572](imgs\image-20250105150350572.png)

### 1. 函数依赖

#### 数据依赖的概念

一个关系内部属性值之间相互依赖又相互制约的关系。

* 函数依赖
* 多值依赖

#### 函数依赖

* 平凡与非平凡的函数依赖
* 完全函数依赖与部分函数依赖
* 传递函数依赖

#### 关系键的形式定义

* 候选码与主码
* 码的性质：
  * 唯一性
  * 最小性
* 主属性与非主属性
* 外部码

#### 函数依赖的逻辑蕴含

如果从F中的函数依赖能够推出X$\rightarrow$Y，则称F逻辑蕴含X$\rightarrow$Y。

函数依赖集F的闭包：$F^+$

#### Armstrong公理系统

**三条公理**：

* 自反律
* 增广律
* 传递律

**一些推论**:

* 合并规则
* 伪传递规则
* 分解规则

属性集X关于函数依赖集F的**闭包**：$X^+_F$

Armstrong公理系统的**有效性**和**完备性**

函数依赖集等价：

* $F^+=G^+\iff$$F与G等价$$\iff$$F覆盖G，G覆盖F$

函数依赖集的最小依赖集：

* 定义：
  * 右部单属性化
  * 没有多余的FD
  * 每个FD左部没有多余属性
* 极小化处理：
  * 单属性化
  * 去除左部多余属性
  * 去除多余函数依赖

### 2. 范式

#### 1NF

定义：当一个关系只包含**原子值**这一约束时，成为1NF。

满足这个约束条件的关系称为规范化关系，简称范式。

#### 2NF

定义：若$R\in1NF$，且每个**非主**属性**完全依赖**于码，则称$R\in2NF$。

规范化：采取**投影分解**方法，消除1NF中非主属性对码的部分函数依赖。

#### 3NF

定义：

* 关系模式$R<U,F>$中，若不存在这样的码X，属性组Y及非主属性$Z(Z\nsubseteq Y)$，使得下式成立：$X\rightarrow Y,Y \rightarrow Z, Y \nrightarrow X$，则称$R\in3NF$。
* 若关系模式$R\in2NF$，且每个非主属性都不传递依赖于R的任何码，则$R\in3NF$。

规范化：采取**投影分解**方法，消除2NF中非主属性对码的传递函数依赖。

#### BCNF

定义：若关系模式$R<U,F>$，如果对于R中的每个函数依赖$X\rightarrow Y$，且$Y\nsubseteq X$时，X必含有码，则$R\in BCNF$。

性质：

1. 所有非主属性都**完全**函数依赖于**每个**候选码
2. 所有主属性都**完全**函数依赖于**每个不包含它**的候选码
3. 没有任何属性完全函数依赖于非码的任何一组属性

#### 多值依赖与第四范式

**多值依赖的定义**

$Z = U - X - Y$。关系模式$R(U)$中多值依赖$X\rightarrow \rightarrow Y$成立$\iff$对$R(U)$的任一关系r，给定的一对$(x,z)$值有**一组**$Y$的值，这组值**仅仅取决于x值而与z值无关**。

**多值依赖与函数依赖的比较**——有效性范围

* 看全集
* 看Y的子集

**多值依赖的性质**

* 多值依赖有**对称性**
* 函数依赖是多值依赖
* 平凡的多值依赖与非平凡的多值依赖：看Z是否等于$\phi$
* 若Y、Z都多值依赖于X，则$YZ、Y\cap Z、Y-Z、Z-Y$都多值依赖于X

**4NF** 

定义：

* $R\in1NF$，对于每个**非平凡**的多值依赖$X\rightarrow\rightarrow Y(Y\nsubseteq X)$，X都**含有码**。

* $R\in BCNF$，且不存在**非平凡且非函数依赖的多值依赖**。

4NF所允许的非平凡的多值依赖实际上是函数依赖。

#### 规范化

目的：消除插入异常、删除异常、数据冗余、更新异常

基本思想：使一个关系只描述一个实体或者实体间的一种联系

设计原则：“一事一地”

规范化的实质：概念的单一化

规范化的过程：见下图

![image-20250105160703255](imgs\image-20250105160703255.png)

#### 范式之间的关系

包含于次一级的范式

### 3. 模式分解理论

#### 模式分解的定义

* 投影的概念
* 模式分解的概念

#### 分解的无损连接性

**定义**: $r \ 等于 \  m_p(r), 即r在p中各关系模式投影上的自然连接$，则称分解p具有无损连接性，简称p为无损分解。

**无损分解的判定算法**

$F=\{FD_1,\dots, FD_p\}$

* 如果将n个属性的关系模式分解为k个，先建立n列k行的表TB：
  * 每一列对应一个属性$A_i$。
  * 每一行对应分解中的一个关系模式$R_i$。
  * 分量的取值：$C_{ij}=A_j∈U_i?a_j:b_{ij}$。
* 对$FD_i$中每一个函数依赖$X\rightarrow Y$，若TB中存在元素t1和t2使，t1[X]=t2[X]，则对每一个$A_i∈Y$：
  * 若$t1[A_i], t2[A_i]$有一个等于ai，则另一个也改为ai。
  * 若上面不成立，就取$t1[A_i]=t2[A_i]$。（t1行号小于t2）
* 反复执行上一步直到：
  * TB出现一行为全a，即为无损分解。
  * TB不变且没有一行为全a，为有损分解。

**无损分解的判定准则**：

分解$ρ=\{R_1<U_1,F_1>,R_2<U_2,F_2>\}$具有无损连接性的充分必要条件是，$U_1∩U_2\rightarrow U_1-U_2∈F^+$或$U_1∩U_2\rightarrow U_2-U_1∈F^+$。

即$R_1, R_2$的共同属性至少构成$R_1,R_2$两者之一的候选码。

#### 分解的保持函数依赖性

**定义**：$F^+=(\cup_{i=1}^nF_i)^+$

**判定方法**：$R中的每个函数依赖都能够从R_1...R_n函数依赖的\textbf{并集}中逻辑导出$

#### 模式分解的原则

投影分解中应遵循的原则：

* 具有无损连接性
* 保持函数依赖

模式分解能够达到的范式等级：

* 保持函数依赖$\rightarrow$3NF，但不一定能达到BCNF

* 无损连接性$\rightarrow$达到4NF或者更高。
* 既保持函数依赖，又具有无损连接性$\rightarrow$3NF，但不一定能达到BCNF

#### 模式分解的算法

##### 达到3NF且保持函数依赖的分解算法

* 对F进行**极小化**
* **去掉不在F中出现的属性**，单独组成一个关系模式，并从U中去掉它们
* 若有$X\rightarrow A\in F$，且$\textbf{XA=U}$，则$ρ=\{R\}$，算法终止
* 对F**按具有相同左部的原则进行分组**，每一组函数依赖所涉及的属性全体为$U_i$。若有$U_i \subset U_j(i\neq j)$，则去掉$U_i$。==**令$F_i$为$F$在$U_i$的投影**==，则$ρ=\{R_1<U_1,F_1>,...\}$

##### 达到3NF且同时保持无损连接与函数依赖的分解算法

设$X$为$R<U,F>$的**码**：

* 得到R的一个保持函数依赖的3NF分解ρ。

* 若有某个$U_i$，$X\subset U_i$，则ρ即为所求；

  否则$ρ\cup\{R'<X,F_X>\}$即为所求。

##### 达到BCNF且保持无损连接的分解算法

1. 令$ρ=\{R<U,F>\}$。

2. 检查$ρ$中各关系模式是否属于BCNF。若是，则算法终止。

3. 设$ρ$中$R_i<U_i,F_i>$不属于BCNF：则存在函数依赖$X\rightarrow A\in F_i^+(A\notin X)$，且$X$不是$R_i$的码。

   将$R_i$分解成$S_1,S_2$。其中$U_{S_1}=XA、U_{S_2}=U_i-\{\textbf{A}\}$。最后将$S_1、S_2$代替$R_i$，并返回第2步。

### 4. 候选码的求解理论和算法

**属性的分类**：$L类、R类、N类、LR类$

#### 快速求解候选码的充分条件

* L类属性、N类属性是任何候选码成员
* R类属性不出现在任何候选码中

#### 左边为单属性的函数依赖集候选码成员的图论判定方法

**前提**：单属性依赖集

**定义**：

* 原始点、终结点、途中点、孤立点
* 关键点：原始点 + 孤立点
关键属性：关键点对应的属性
* 独立回路：不能由其他结点到达的回路

**定理**：

* 关键点在任何候选码中，终结点不在任何候选码中
* 候选码**唯一** $\iff$ **无独立回路**
* **途中点**Y在某个候选码中 $\iff$ Y在某个独立回路中

**算法**：

1. 求F的**最小依赖集**$F_m$;

2. 构造**函数依赖图**$G$；

3. 从$G$中找出**关键属性集**$X$;

4. $G$中若没有独立回路，则$X$即为**唯一候选码**；

   否则，从各独立回路中各取一结点对应的属性与X组成一个候选码，直至取尽所有组合，即为**全部候选码**。

#### 多属性依赖集候选码求解法

1. 令$X$代表$L、N$类，$Y$代表$LR$类；
2. 依次从$Y$中向$X$中转移属性，并求$X$的闭包，直到其闭包包含$R$的全部属性。

---

## 第六章 数据库设计

![image-20250105200719071](imgs\image-20250105200719071.png)

### 0. 前言

#### **数据库设计的定义**：

* 是指对于一个给定的应用环境，设计**优化**的数据库**逻辑结构和物理结构**，**建立数据库**，使之能够有效地存储数据，为开发满足用户需求的应用系统奠定基础。

#### **数据库设计的特点**：

* 要把**数据设计**和**处理设计**密切结合
* 与硬件、软件、管理密切相关

#### **数据库设计的方法**:

* 手工试凑法（直接设计法）

* **数据库规范设计方法**：
    1. 需求分析

    2. 数据库概念结构设计：形成**概念模型**（E-R图）

    3. 数据库逻辑结构设计：形成**数据模型**（模式、子模式）

    4. 数据库物理结构设计：设计**存储结构**和**存取方法** （内模式）

    5. 数据库实施：建立数据库，即用DDL描述三级模式

    6. 数据库运行和维护

### 1. 需求分析

#### 需求分析的目标

调查的重点是：数据 + 处理

* 处理要求
* 信息要求
* 安全性与完整性的要求

#### 需求分析的方法

* **数据流图**：表达数据和处理之间的关系

* **数据字典**：描述系统中各类数据

  需求分析阶段的数据字典可以看成是数据元素表；而数据库实施阶段建立起的数据字典，则是数据库系统重要组成部分。二者不一样。

### 2. 概念结构设计

#### 概念结构设计的工具——E-R法

*具体内容见概论*

  #### 应用系统的概念结构设计方法

**四类方法**：

* 自顶向下
* **自底向上**：最常用的方法。分为两个阶段：
  * 局部E-R图设计
  * 综合局部E-R图形成总E-R图
* 逐步扩张
* 混合策略

#### 局部E-R图设计步骤

* 选择局部应用
* 建立实体模型
* 确定联系类型
* 形成分E-R图

#### 数据抽象机制

* 分类
* 聚集
* 概括

#### 实体模型的调整原则

* 属性必须是不可分的数据项
* 属性不能与其他实体具有联系
* 实体和属性之间保持1:1或n:1的联系

#### 综合分E-R图形成总E-R图

* 合并：解决冲突，形成初步E-R图

  * 属性冲突
  * 命名冲突
  * 结构冲突

* 修改和重构：消除冗余，形成基本E-R图

  冗余分类：

  * 冗余数据
  * 冗余联系

  消除方法：

  * 分析法
  * 规范化方法

### 3. 数据库逻辑结构设计

逻辑结构设计的任务就是将概念结构转换为选用的DBMS所支持的数据模型的过程。包括下面四个任务：

#### 形成初始关系数据库模式

* 一个实体型转换为一个关系模式
* 一个联系转换为一个关系模式
* 具有相同码的关系可以合并
* 弱实体类型：标识关系的主码作为新关系的外码；新关系的主码是标识关系的主码+弱实体类型的部分标识
* 超类/子类：超类中有共有属性+主码+子类判定符；子类中有超类主码+子类特有属性。

#### 关系模式规范化

应用关系数据理论

#### 关系模式优化

按应用系统的处理要求，确定是否要进行模式合并或模式分解。

为了提高**存取效率**和**存储空间的利用率**，可以对关系模式进行分解：

* 水平分解：80/20原则、数据分片
* 垂直分解：必须确保无损连接性和保持函数依赖

#### 设计用户子模式

子模式：视图

### 4. 数据库的物理结构设计

数据库物理结构包括数据在物理设备上的存储结构与存取方法。

#### 确定数据库的存储结构

* 确定存放位置
* 确定系统配置

#### 选择关系的存取方法

> 选择关系的存取方法是使事务能够快速存取数据库中数据的技术

**(1) 索引方法**

* 索引记录/索引项：索引域 + 指针

* B+树

**(2) 聚集方法**

* 一个关系只能参加一个聚集

**(3) Hash方法**

---

# 第三大部分 实现技术

* 存储管理程序
* 查询处理程序
* 事务管理程序

## 第七章  存储管理与索引

![image-20250105213757897](imgs\image-20250105213757897.png)

### 0. 物理存储系统

* DBMS设定数据库的基本存储是在磁盘上，DBMS管理内存与外存数据的交换。

* DBMS**存储管理的目标**：**最小化磁盘和主存间传输存储块的数量，即最小化磁盘存取次数。**

  实现手段：在主存中保持尽量多访问概率大的块。

* 磁盘块：简称块，又通常指页。由若干连续扇区组成，是存储分配和检索的逻辑单元。数据以块为单位在磁盘和主存之间传输。

* 物理存储管理器：又称为磁盘管理器。是DBMS结构的最底层。

### 1. 数据存储结构/物理结构

#### 概述

* 数据库—文件—块/页
* 文件的组织结构 是 文件中记录的组织方式
* 块是存储分配和数据传输的单位
* 数据库的表被映射为底层存储中的文件
* 一个文件在逻辑上被组织为记录的序列，记录被映射到磁盘块上
* 一个块可以包含几个记录，每条记录被完全包含在单个块中
* 每个记录有唯一的标识符：块号 + 记录在块中的位置

#### 数据库文件的存储介质结构

##### 文件的结构

表/文件所占磁盘块的分配方法：

* 连续分配
* 链接分配
* 按簇分配：前两种方法的结合
* 索引分配

##### 页/块的结构

* 页/块是**固定大小**的数据块

* 页/块的结构：Header + 数据

  Header包含页中数据的元数据

* **最常用的结构是分槽结构**

  * Header：已使用槽数 + 最后一个被用槽的起始位置偏移量 + 槽数组

  * 槽数组保存了每个元组的起始位置偏移量

  * 便于存储变长记录

##### 记录的结构

* 记录是**字节序列**，DBMS负责将该序列解释为属性类型和值。

  * 记录头部：元组头数据

  * 记录数据：属性的实际数据

  * 唯一标识符：页ID + offset或槽

    > 应用程序不能依赖该ID进行唯一性标识

#### 文件的记录组织

* **堆**：记录可以存放在文件空间中的任何位置

  * 链表方式
  * 页目录方式

* **顺序**：文件中的记录按**搜索码**顺序排列

* **索引**：记录的关键字与相应记录的存储地址的对照表

  索引文件的组成：

  * 索引表：按关键字有序
  * 主文件：索引顺序文件 或 索引非顺序文件

* **散列**：在搜索码上的hash函数，计算出记录在文件中存放的块

* **聚集**：具有相同或相似属性值的记录存储于连续的磁盘块中，以减少IO次数

  * **聚集码**是一种属性，定义了哪些记录被存储在一起。

  * 多表聚集：加快特定的连接查询，会使单个表的访问变慢。

### 2. 缓冲区管理

#### 缓冲区管理系统

* 缓冲区
* **缓冲区管理器**：负责缓存空间分配，内外存交换
* 管理目标：最小化磁盘和主存间传输存储块的数量，即最小化磁盘存取次数；实现手段是在主存中保持尽量多的块。

#### 缓冲区组织与管理

* 缓冲区被组织为一个**固定大小**的**页面数组**。每个元素称为帧，存放磁盘上的一个页/块。

* 缓冲区元数据——页表：

  记录当前内存所有页的访问情况，并保存每个页的元数据，包括Dirty Flag、Pin/Reference计数器等

* 缓冲区中的共享锁与排它锁

* 缓冲区替换策略：LRU

### 3. 索引

#### 索引的基本概念

索引记录/索引项：索引域（搜索码） + 指针

#### 索引的分类

##### 两种基本类型：

* 排序索引
* 哈希索引

##### 聚集索引与非聚集索引:

根据索引域/搜索码值的排列顺序是否与记录在文件中的排列顺序一致分。

*$注：我认为这里的聚集索引和非聚集索引 与 上面的索引顺序文件和索引非顺序文件是一致的$*

##### 稠密索引与稀疏索引:

根据文件中的每个搜索码值是否都有索引项分。

当文件记录以索引域排序时可以使用稀疏索引。

非聚集索引都是稠密索引。

#### 多级索引

索引规模大，无法全部放入内存，导致性能下降。对索引文件建立稀疏索引

* 外层索引
* 内存索引

##### 二叉树索引

##### 多枝树索引

##### B树（平衡树）索引

* 定义 ：是附加限制条件的索引树，限制了每个节点最多和最少的关键字个数。

    - **根节点**：有 $[2, n]$ 个子节点。  
    - **中间节点**：有 $[⌈n/2⌉, n]$ 个子节点。  
    - **叶节点**：有 $[⌈(n-1)/2⌉, n-1]$ 个记录指针。  
    - $n$ 值固定。

* 特性：
  * 从树根到叶节点的**路径长度相同**，所有叶节点都在同一层。
  * 关键字分布在所有层。

##### B+树

* 定义：B+树是 B 树的改进版本。

  * 把树中所有关键字都**按递增次序从左到右**安排在**叶节点**上，并且**链接起来**。
  * B+树根节点、中间节点、叶节点的关键字与指针的最小和最大个数与B树相同。
  * 每个节点最多包含 $n-1$ 个搜索码/索引码/关键字值，以及 $n$ 个指针。

* 特性：

  * 支持随机查找和顺序查找。
  * 关键字分布在叶节点上。
  * 叶节点存储的是记录而不是记录的指针。

* 查询
  
* 更新：插入、删除

#### Hash索引

##### 哈希表

* Hash索引基于哈希表实现。
* Hash表实现key到value的映射。
* Hash函数：映射函数
* 哈希表：存放记录的数组
* 哈希表的实现：
  * 哈希函数
  * 哈希方案：解决哈希冲突，如溢出链接法

##### 分类

* 静态哈希：哈希表的大小固定
* 动态哈希：允许哈希表的大小动态修改
  * 定期重哈希
  * 线性哈希

---

## 第八章 查询处理与查询优化

![image-20250106000424992](imgs\image-20250106000424992.png)

### 1. 查询处理概述

#### 查询处理的步骤

* 查询分析
* 查询检查
* 查询优化
* 查询执行

#### 查询代价的度量

* 与多个因素有关。
* 从磁盘访问数据的**I/O代价**通常是最重要的代价。使用**访问磁盘的块数**作为估计代价的因素。

### 2. 主要查询操作的实现方法

#### 选择运算

* 全表扫描法
* 索引扫描法

#### 连接运算

* 嵌套—循环法

  应选择较小表作为外表。

* 索引连接法

  以元组较少的有索引的关系作为外层关系。

* 排序—合并法

  只能用于等值连接或自然连接。

* Hash join法（哈希连接法）

  只能用于等值连接或自然连接。

#### 排序运算

* 快速排序算法：内存中可以完全容纳的关系
* 外排序-归并算法：内存中无法完全容纳的关系

#### 去重运算

* 排序方法
* 哈希方法

#### 投影运算

先在每个元组上执行投影，然后去重

#### 集合运算——并、差、交

* 类似排序-合并连接
* 类似哈希连接

#### 库函数

基于分组属性进行排序或散列 以聚集同组的元组，再执行库函数。

### 3. 表达式的执行

* 物化方法：存临时表

  特点：适用性广，读写代价大

* 流水线方法：将结果传递给下一个运算

  特点：代价小，适用性低、不适用于排序

### 4. 查询优化概述

#### 必要性

略

#### 目标

 选择一个高效执行的查询处理策略，使得查询代价最小，即访问磁盘的块数最小。

#### 结果

得到查询计划

#### 分类

按照优化的层次进行分类：代数优化 + 物理优化

### 5. 代数优化

#### 代数优化基本概念

通过对**关系代数表达式的等价变换**来提高查询效率。

#### 等价变换规则

> 不用背

1. 连接、笛卡尔积的交换律
2. 连接、笛卡尔积的结合律
3. 投影的串接定律
4. 选择的串接定律
5. 选择与投影的交换律
6. 选择与笛卡尔积的交换律
7. 选择与并的分配律
8. 选择与差的分配律
9. 选择与自然连接的分配律
10. 投影与笛卡尔积的分配律
11. 投影与并的分配律

#### 优化的一般准则（查询树的启发式优化）

* 减小中间关系：减少元组数据 + 减少属性数目

  **把选择、投影操作尽量往前移**

  ==**选择运算**尽早执行，是优化策略中**最重要、最基本**的一条==

* 减少扫描关系的次数

* 把笛卡尔积与选择转换为连接

* 中间结果复用

#### 查询树的优化

* 查询树是关系代数表达式的树形表示
* 分组：
  * 双目运算和它的直系祖先（选取、投影）为一组
  * 双目运算后代直到叶子全是单目运算时并入该组。但是笛卡尔积的后面若不是与之可以合并为自然连接的等值选择时，其后代要单独一组
* 生成查询代码时，需保证任何一组的计算不在后代组之前计算。

### 6. 物理优化

选择高效合理的底层操作算法或存取路径。 

#### 基于规则的启发式优化方法

启发式规则：

* 选择操作

  * 小关系：全表顺序扫描
  * 大关系：索引扫描法、全表顺序扫描

* 连接操作

  根据条件选择 索引连接法、排序—合并法、Hash join法、嵌套循环法

#### 基于代价估算的优化方法

利用数据库的统计信息计算各种操作算法的执行代价。

#### 两者结合的优化方法

### 7. 查询优化的一般步骤

* 把查询转换成语法树（查询树）
* 代数优化
* 利用基于启发式规则的物理优化，选择底层的操作算法与存取路径，生成查询计划；利用基于代价的物理优化，选择代价最小的。

---

## 第九章 事务处理技术

![image-20250106010418214](imgs\image-20250106010418214.png)

### 1. 事务的概述

#### 事务的概念

事务是**用户定义**的数据库**操作序列**，这些操作要么都做，要么都不做，是一个**不可分割**的**工作单位**。

* 事务是**数据库恢复**和**并发控制**的**基本单位**。
* 事务与应用程序是两个概念，一个应用程序可以包含多个事务。

#### 事务的特性 ACID

##### 内容

* 原子性 Atomicity 由恢复机制实现

* 一致性 Consistency 由事务的原子性保证

* 隔离性 Isolation 由并发控制机制实现

* 持久性 Durability 由恢复机制实现


##### 地位

事务的ACID特性对于数据库数据的**正确**、**有效**具有重要意义。

##### 破坏

特性被破坏的两种情况：

* 多个事务并发运行时，不同事务的操作交叉进行——对应并发控制技术
* 事务在运行过程中被强行停止——对应数据库恢复技术

#### 事务的定义

事务的开始与结束可以由**用户显示控制**，也可以由DBMS按缺省规定**自动划分**。

**SQL中事务的定义**：

* 事务开始：$BEGIN\ TRANSACTION$
* 事务结束：
  * 提交事务，正常结束：$COMMIT$
  * 回滚到开始时状态，非正常结束：$ROLLBACK$

### 2. 数据库恢复技术

#### 数据库恢复技术的概述

**定义**：数据库管理系统必须具有把数据库从**错误状态**恢复到某一已知**正确状态**的功能，这就是数据库的恢复。

**基本原理**：数据库恢复是通过数据库管理系统的**恢复子系统**完成的。

**意义**：    

*  保证事务的**原子性**，实现事务非正常终止时的回滚
* 当**系统发生故障**以后，数据库能够恢复到正确状态

#### 故障的种类

* **事务内部的故障**

  * 可预期的
  * 不可预期的：死锁、运算溢出、违反完整性规则

* **系统故障**

  是指**造成系统停止运行**的任何事情，如硬件错误、操作系统故障、停电。

  事务都**异常中止**，但**不会破坏数据库**。

* **介质故障**

  指外存故障。

  **破坏全部或部分数据库**，并影响**正在存取这部分数据的所有事务**。

* **计算机病毒**

  多数病毒对数据进行非法修改。

#### 恢复的实现技术

##### **故障对数据库系统的两种影响**

* 数据库本身被破坏：介质故障
* 数据库没有破坏，但数据可能不正确：
  * 事务的非法终止：事务内部的故障、系统故障
  * 计算机病毒

##### **数据库恢复的原理**：**<big>冗余</big>**

##### 数据转储

* 定义：是DBA定期地将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据文本称为**后备副本**或**后援副本**。
* 两种转储状态：

  * 静态转储：无事务运行，无存取、修改
  * 动态转储：转储期间允许对数据库进行存取或修改。对于动态转储，**后援副本加上日志文件**就能把数据库恢复到某一时刻的正确状态。
* 两种转储方式：
  * 海量转储
  * 增量转储

##### 日志文件的建立与使用

* 日志的定义：日志是用来**记录事务对数据库==更新==操作**的文件。
* 日志文件的格式：
  * 以记录为单位
  * 以数据块为单位
* 日志文件的作用：
  * **事务故障**和**系统故障**的恢复必须使用日志文件。
  * 对于动态转储方式：后备副本和日志文件综合起来才能恢复数据库。
  * 对于静态转储方式：用日志文件恢复转储结束时刻到故障点间的事务。
*  日志文件的写入规则：
  * 登记的次序按事务执行的次序
  * **先写日志文件，后写数据库**

#### 故障的恢复策略

##### 事务故障的恢复：UNDO

在不影响其他事物的情况下，**强行回滚**，撤销已做的修改。具体步骤：

* ==反向==扫描日志文件
* 对更新操作执行逆操作
* 直到读到该事务的开始标志

##### 系统故障的恢复：UNDO + REDO

* ==正向==扫描日志文件

* 撤销(UNDO)故障发生时未完成的事务。
* 重做(REDO)已完成但没有写入数据库的事务。

##### 介质故障的恢复

* 装入最新的数据库**后备副本**，使得数据库恢复到最近一次转储时的**一致状态**。对于动态转储，还需要装入日志文件副本（注：这样才算达到一致状态嘛）。
* 装入**转储以后**的**日志文件副本**，重做已经完成的事务。

#### 具有检查点的恢复技术

##### 意义

检查点技术可以改善效率，使得在检查点之前提交的事务，在数据库恢复处理时不必重做。

##### 结构

* 在日志文件中增加**检查点记录**
* 检查点记录的内容：
  * 建立检查点时刻所有**正在执行**的事务清单
  * 这些事务**最近**一个日志记录的地址
* **重新开始文件**：记录各个检查点记录在日志文件中的地址

##### 实现

恢复子系统**动态维护日志文件**：

* 将日志缓存中的**日志记录**写入磁盘的日志文件
* 在日志文件上写入一个**检查点记录**
* 将数据缓存中的**数据记录**写入数据库
* 将检查点记录在日志文件中的地址**写入重新开始文件**

##### 恢复

* 利用**重新开始文件**定位**最近检查点记录**
* 找到检查点时刻的**运行事务清单**：入UNDO-LIST
* 确定需要撤销和重做的事务：从检查点开始正向扫描日志文件，新开始的事务入UNDO-LIST，提交的事务入REDO-LIST
* 执行撤销或重做动作

#### 数据库镜像

另一个磁盘

### 3. 并发控制技术

#### 3.1 并发控制的概述

##### 事务并发执行的优点：

* 提高系统吞吐量
* 减少平均响应时间

##### 事务并发执行的问题：

  当**多个事务同时存取同一数据**时，可能破坏数据库的**一致性**：

* 丢失修改
* 脏数据的读出
* 不能重复读

##### 并发控制的基本思想：

合理调度并发事务，避免并发事务之间的互相干扰造成数据的不一致性。

主要方法是采用<big>**封锁机制**</big>。

#### 3.2 封锁

##### 基本锁的类型

* 排它锁：X锁
* 共享锁：S锁

只有S锁和S锁相容，其他组合都互斥

##### 三个封锁协议

* 一级封锁协议——防止丢失修改

* 二级封锁协议——防止读脏数据

* 三级封锁协议——保证数据可重复读

 三级协议的主要区别在于**何时加锁**以及**何时放锁**：![image-20250106140745539](imgs\image-20250106140745539.png) *$注：申请的X锁都是在事务结束后释放$*

##### 封锁的粒度

封锁粒度：封锁对象的大小

* 封锁粒度大，则并发度低， 封锁机构简单、开销小。
* 封锁粒度小，则并发度高， 封锁机构复杂、开销大。

##### 多粒度封锁

* 定义：同时支持**多种封锁粒度**供不同的事务选择。选择封锁粒度时应同时考虑**封锁开销**和**并发度**两个因素。

* 多粒度树
* 多粒度封锁协议：允许多粒度树中的每个节点被独立地加锁。对一个结点加锁意味着所有后裔结点也被加以同样类型的锁。

* 多粒度封锁的两种封锁方式:

  * 显示封锁
  * 隐式封锁

  > 显示封锁与隐式封锁的效果一样


##### **意向锁**

* 具有意向锁的多粒度封锁方法中，任意事务对任意数据对象加锁时，必须 **先** 对其上级对象结点加意向锁。
  * 申请封锁的顺序：自上而下
  * 释放封锁的顺序：自下而上

* 三种常用的意向锁
  * 意向共享锁：IS锁
  * 意向排它锁：IX锁
  * 意向共享排它锁：SIX锁 = S锁 + IX锁

* 意向锁的相容矩阵：自己分析即可

#### 3.3 活锁与死锁

##### 避免活锁的简单方法

* 先来先服务

##### 解决死锁的方法

* 预防死锁

  * 一次封锁法
  * 顺序封锁法
* 死锁检测和解除

  * 死锁的检测：

    * 超时法
    * 等待图法
  * 死锁的解除：
    * **撤销**一个处理死锁**代价最小**的事务

#### 3.4 事务的调度

##### 事务调度的定义

* 一个事务内的各操作顺序保持不变

##### 事务并发调度的正确性

* 一组事务的串行调度策略一定是正确的调度策略，即使结果可能不同。

##### 并发调度的可串行性

* 可串行化调度：并发执行结果与按某一次序**串行执行**结果相同的调度

* 一个并发调度是正确调度 $\iff$ 它是可串行化的

##### 可串行化调度的判定

* 冲突操作的定义：**不同事务**对**同一数据**的**读-写**操作及**写-写**操作
* 冲突可串行化调度的定义：可以通过交换两个事务**不冲突操作**的次序得到串行调度的调度
* 可串行化调度的**充分条件**：冲突可串行化调度是可串行化调度

##### 两段锁协议

* 内容：在对数据进行读写操作前，事务要获得对该数据的封锁；在释放一个数据之后，事务不再获得任何其他封锁。
* 含义：事务分为两个阶段：**扩展阶段** +  **收缩阶段**
* 性质：若**所有事务**均遵从**两段锁协议**，则这些事务的并发调度是可串行化的。（充分条件）
* 注意：不要求一次获得所有需要的锁，所以仍然可能发生死锁。

#### 3.5 事务隔离级别

读未提交、读已提交、可重复读、可串行化

脏读、不可重复读、**幻读**

![image-20250106144330453](imgs\image-20250106144330453.png)

#### 3.6 悲观并发控制与乐观并发控制

根据是否假定会发生并发冲突分类

* 悲观并发控制

  * 三级封锁协议
  * 两段锁协议

* 乐观并发控制：提交操作时检查，做冲突处理

  * 时间戳排序协议
  * 乐观并发控制协议

冲突少、执行时间短的情况适用乐观并发控制OCC

##### 时间戳排序协议

* 定义：给每个事务分配一个**全局唯一**的时间戳，使得所有事务单调顺序
* 事务只能访问该事务时间戳前面的数据
* 可以产生**冲突可串行化调度**
* 冲突处理：终止其中一个事物，回滚并重新调度，同时赋予新的时间戳

##### 乐观并发控制协议

* 三个阶段：
  * 读阶段：从数据库读到私有工作区，并在私有工作区写数据
  * 验证阶段：发生冲突则重启事务
  * 写阶段：将**私有工作区**的更新刷新到数据库中

#### 3.7 多版本并发控制 MVCC

* 版本的产生与使用：
  * 写操作：产生该数据的一个新版本
  * 读操作：读取**事务开始时**该数据的**最新版本**
* MVCC是用来解决**读写冲突**的**无锁并发控制**
  * 实现读已提交和可重复读，即解决了脏读和不可重复读
  * 不能解决丢失更新问题
* MVCC与悲观、乐观并发控制技术（解决写写冲突）相结合，提高并发性能


---

# 第四大部分 新技术

## 第十章 数据库技术新发展

![image-20250106150512186](imgs\image-20250106150512186.png)

### 0. 数据库技术新发展概述

**数据仓库**

* 定义：数据仓库是**支持管理决策过程**的、**面向主题**的、**集成**的、**随时间而增长**的**持久数据集合** 
* 数据仓库上的业务处理称做**联机分析处理**；数据库上的业务处理称作**联机事务处理**。

> 接下来讲分布式数据库系统

### 1. 分布式数据库系统的概述

> 物理上的分布性
>
> 逻辑上的整体性

#### 分布式数据库定义

分布式数据库是由一组分布在计算机网络的不同结点上的数据组成。每个结点具有独立处理的能力（**场地自治**），可以**执行局部应用**。同时每个结点也能通过网络通信**支持全局应用**。

* 前提：数据分布
* 强调：场地自治（局部应用） + 自治场地之间的协作性（全局应用）

#### 分布式数据库系统的特点

* **数据独立性**

  * 数据的逻辑独立性
  * 数据的物理独立性
  * 数据的**分布独立性**(分布透明性)

* **集中与自治相结合的控制结构**

  局部DBMS具有**自治功能**，系统又设有**集中控制结构**。

  数据的共享的两个层次：

  * 局部共享
  * 全局共享

* **适当增加数据冗余**

  优点：

  * 提高系统的可靠性、可用性
  * 提高系统性能

  缺点：不利于更新，增加系统维护代价

* **全局的 一致性、可串行性、可恢复性**

### 2. 分布式数据库系统的模式结构![image-20250106152856209](imgs\image-20250106152856209.png)

* 全局外模式—全局概念模式映像
* 全局概念模式—分片模式映像
* 分片模式—分布模式映像
* 分布模式—局部概念模式映像

### 3. 数据分片

#### **数据分片的方式**

* **水平分片**：不相交子集，每个子集叫作一个水平分段
* **垂直分片**：每个子集叫作一个垂直分段，通常都包含关系的码
* **导出分片**：导出水平分片，分片的条件是其他关系的属性条件。
* **混合分配**：其他分片方法的结合。

#### 数据分片的约束

* 完全性
* 不相交性：垂直分片的码属性除外
* 可重构性：
  * 垂直分片用连接操作重构
  * 水平分片用并操作重构

### 4. 分布透明性（分布独立性）

依次对应分片模式、分布模式、局部概念模式

* 分片透明性：分布透明性的最高层次
* 位置透明性
* 局部数据模型透明性

### 5. 分布式数据库管理系统 DDBMS

#### DDBMS的组成

* LDBMS 局部场地上的数据库管理系统

  提供场地自治能力

* GDBMS 全局数据库管理系统

  提供分布透明性

* GDD 全局数据字典

* CM 通信管理

#### DDBMS的分类

按全局控制方式分类：

* 全局控制集中的DDBMS

  GDBMS和GDD集中在一个结点

* 全局控制分散的DDBMS

  每个结点上都有GDBMS和GDD，又叫完全分布的DDBMS

* 全局控制部分分散的DDBMS

按局部DBMS的类型分类：

* 同构型DDBMS
* 异构性DDBMS

### 6. 分布式查询处理和优化

#### 查询的类别

* 局部查询：单个结点，本地
* 远程查询：单个结点，远程
* 全局查询：多个结点

#### 查询优化的目标

* 查询执行的开销：I/O代价 + CPU代价 + 通信代价

* 分布式查询优化：分布优化 + 局部优化

  分布优化更重要 

* **查询优化的首要目标是使查询执行时通信代价最省**

  通信代价是首要因素，TC(X) = C0 + X * C1

* 连接查询的优化是重要问题

* 半连接：使用半连接缩减关系或片段来节省传输开销

  > 左表驱动右表，只返回左表的数据，右表作为筛选条件

  * 定义:![image-20250106160939797](imgs\image-20250106160939797.png)

  * 应用：![image-20250106161047299](imgs\image-20250106161047299.png)当R中参与连接的元组足够少时，可以采用半连接


### 7. 分布事务处理

#### 分布事务处理的概述

##### 分布式事务的原子性与可串行性

一个全局事务被划分为许多结点上的子事务

* **分布式事务的原子性**：**组成该事务的所有子事务要么一致地全部提交，要么一致地全部回滚**。
* 在多用户系统中，还必须保证分布式事务的可串行性

##### 分布事务管理

* 事务的恢复
* 并发控制

#### 分布事务的恢复——两段提交协议

对**局部事务管理器**进行协调，**保证分布事务原子性**的最常用的技术——两段提交协议。

局部事务管理器分类：

* 协调者：仅一个
* 参与者

两段提交协议的内容：

* 第一阶段：协调者征求意见做决定
* 第二阶段：参与者执行决定

#### 并发控制

略

### 8. 融合云计算技术的数据库系统

略

#  杂论

* 弹性可扩展是云原生数据库的本质。

* 数据结构化是数据库主要特征之一，是数据库与文件系统的根本区别

* 如果关系模式R中所有属性都是主属性，一定属于3NF，但不一定属于BCNF。

* 数据完整性是指数据的正确性和相容性

* 数据库系统与文件系统本质区别是：数据库系统实现整体数据的结构化，而文件系统中数据之间是孤立的

* 关系的性质：

  1. 列是同质的
  2. 不同的列可以出自同一个域，每列必须有不同的属性名
  3. 列的顺序无关紧要，即列次序可以互换
  4. 任意两个元组不能完全相同
  5. 行的顺序无关紧要，即行次序可以互换
  6. 每一分量必须是不可再分的数据

* sql支持数据定义、数据更新、数据查询、数据控制四类操作

  数据控制：

  * 定义完整性约束条件
  * 支持事务操作
  * 提供安全控制功能

* 自主存取控制根据 预先定义的用户权限 进行存取控制
